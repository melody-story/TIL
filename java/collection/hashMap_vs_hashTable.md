`HashMap`과 `Hashtable`은 모두 해시 테이블 기반의 자료구조를 구현한 클래스이지만 몇 가지 중요한 차이점이 있습니다.

1. **동기화(Synchronization):**

    - `Hashtable`: 모든 메서드가 동기화되어 있어 멀티스레드 환경에서 안전하게 사용할 수 있습니다.
    - `HashMap`: 동기화되어 있지 않기 때문에 멀티스레드 환경에서 안전하지 않습니다. 동시에 여러 스레드가 `HashMap`을 수정하는 경우 예기치 않은 결과가 발생할 수 있습니다. 대신 `ConcurrentHashMap` 클래스를 사용하여 안전하게 멀티스레드 환경에서 사용할 수 있습니다.
2. **null 허용 여부:**

    - `Hashtable`: 키와 값으로 null을 허용하지 않습니다. null을 넣으려고 하면 NullPointerException이 발생합니다.
    - `HashMap`: 키와 값 모두 null을 허용합니다. 즉, 키나 값으로 null을 저장할 수 있습니다.
3. **성능:**

    - 일반적으로 `HashMap`의 성능이 `Hashtable`보다 우수합니다. `HashMap`은 동기화되지 않기 때문에 더 빠른 속도를 제공합니다. 그러나 동기화가 필요한 경우 `Hashtable`을 사용할 수 있습니다.
4. **컬렉션 프레임워크와의 호환성:**

    - `HashMap`은 `Map` 인터페이스를 구현한 클래스이며, Java Collections Framework의 일부입니다.
    - `Hashtable`은 JDK 1.0부터 존재하던 클래스로, `Map` 인터페이스를 구현하고 있지만 컬렉션 프레임워크와의 호환성은 덜합니다.

따라서 일반적으로 멀티스레드 환경이 아니고 null을 저장해야 할 때는 `HashMap`을 사용하는 것이 권장됩니다. 멀티스레드 환경이거나 null을 허용하지 않아야 할 경우에는 `Hashtable`을 사용할 수 있습니다. 그리고 더 나은 동기화 및 멀티스레드 성능을 위해서는 `ConcurrentHashMap`을 고려할 수 있습니다.


## 해시맵은 어떻게 구현되어있길래, 키와 값을 빠르게 매핑할 수 있을까?

해시맵(HashMap)은 해시 테이블(Hash Table)을 기반으로 구현되어 있습니다.
해시 테이블은 키-값 쌍을 저장하는 자료구조로, 키를 해시 함수를 사용하여 해시 코드로 변환한 다음, 해당 해시 코드를 인덱스로 사용하여 배열에 저장합니다.
이렇게 하면 키와 값을 빠르게 매핑할 수 있습니다.

여기서 중요한 점은 해시 함수가 키를 해시 코드로 변환할 때 동일한 키에 대해서는 항상 동일한 해시 코드를 생성해야 한다는 것입니다. 이를 통해 해시 테이블의 각 슬롯에는 충돌 없이 한 개의 키-값 쌍만 저장됩니다.

해시맵은 키의 해시 코드를 사용하여 값을 저장하고 검색하기 때문에 매우 빠른 검색 속도를 제공합니다. 일반적으로 해시맵은 평균적으로 O(1)의 시간복잡도를 가지며, 상황에 따라서는 O(n)의 시간복잡도를 갖을 수도 있습니다. 해시맵은 이러한 빠른 검색 속도를 유지하기 위해 해시 충돌을 최소화하기 위한 다양한 기법들을 사용합니다. 이러한 기법에는 충돌을 처리하는 방법(체이닝, 개방 주소법 등)과 해시 함수의 설계 등이 있습니다.

따라서 해시맵은 해시 함수와 충돌 처리 기법을 통해 키와 값을 효율적으로 매핑할 수 있습니다. 이를 통해 매우 빠른 검색 및 삽입/삭제 연산이 가능하게 됩니다.
