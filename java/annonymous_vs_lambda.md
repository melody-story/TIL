# 익명클래스보다는 람다함수를 사용하는 이유

- 함수형 인터페이스 :  상 메서드가 오직 하나인 인터페이스를 의미합니다.

- 익명 클래스는 함수형 인터페이스가 아닌 타입의 인스턴스를 만들 때만 사용하도록 한다.
- 람다는 함수형 인터페이스에서만 쓰인다.
  추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니, 익명 클래스를 써야 한다.
  추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명 클래스를 쓸 수 있다.
- 람다식은 자바에 함수형 프로그래밍의 이점을 가져오기 위해 도입하였다
- 예전에는 자바에서 함수 타입을 표현할 때 추상 메서드를 하나만 담은 인터페이스(드물게는 추상 클래스)를 사용했다.
- 하나의 추상메소드만 가질수있으며, 추상 메소드를 제외하고 default 메소드와 static 메소드 여러개 가질 수 있음. java 1.8 버전부터
- 이런 인터페이스를 `함수 객체`(function object)라고 하여, 특정 함수나 동작을 나타내는 데 썼다.
    - 추상 메서드 하나짜리 인터페이스
- 문자열을 길이순으로 정렬하는데, 정렬을 위한 비교 함수로 익명 클래스를 사용한다.
- 익명 클래스의 인스턴스를 `함수객체`로 사용 - 낡은 기법

```java
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});
```
지금은 함수형 인터페이스라 부르는 이 인터페이스들의 인스턴스를 람다식(lambda expression, 혹은 짧게 람다)을 사용해 만들 수 있게 된 것이다.
람다는 함수나 익명 클래스와 개념은 비슷하지만 코드는 훨씬 간결하다.
다음은 익명 클래스를 사용한 앞의 코드를 람다 방식으로 바꾼 모습이다.
자질구레한 코드들이 사라지고 어떤 동작을 하는지가 명확하게 드러난다.
argument의 타입은 컴파일러에 의해 자동으로 결정될 수 있습니다.
즉 아래와 같이 타입을 생략 할 수 있습니다.

```java
Collections.sort(words,
        (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```
여기서 람다, 매개변수(s1, s2), 반환값의 타입은 각각 (Comparator<String>), String, int지만 코드에서는 언급이 없다.

우리 대신 컴파일러가 문맥을 살펴 타입을 추론해준 것이다.



상황에 따라 컴파일러가 타입을 결정하지 못할 수도 있는데, 그럴 때는 프로그래머가 직접 명시해야 한다.

타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자.



람다 자리에 비교자 생성 메서드를 사용하면 이 코드를 더 간결하게 만들 수 있다(아이템 14, 43).

Collections.sort(words, comparingInt(String::length));


자바 8 때 List 인터페이스에 추가된 sort 메서드를 이용하면 더욱 짧아진다.

words.sort(comparingInt(String::length));

