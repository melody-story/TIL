# 암호화

- 암호화는 데이터를 암호화하여 누구나 이를 이해하지 못하게 만드는 프로세스를 말합니다. 이는 보안 목적으로 사용되며, 데이터의 기밀성을 보장하고 외부로부터의 액세스를 제한하기 위해 적용됩니다. 암호화는 평문(원본
  데이터)을 암호문(암호화된 데이터)으로 변환하는 과정을 의미하며, 그 반대의 과정은 복호화(decryption)라고 합니다.
- 암호화는 다양한 용도로 사용됩니다. 몇 가지 주요한 용도는 다음과 같습니다:
    - **데이터의 기밀성 보호**: 중요한 데이터를 암호화하여 외부의 불법적인 액세스로부터 보호합니다. 이는 데이터가 유출되더라도 암호화되어 있으면 외부에서 읽을 수 없기 때문에 기밀성이 보장됩니다.
    - **데이터 무결성 보호**: 암호화는 데이터가 변경되지 않았음을 보장합니다. 데이터를 암호화하면 누구나 데이터를 수정할 수 없으며, 데이터가 유효한지 확인할 수 있습니다.
    - **인증**: 암호화는 데이터의 출키처를 확인하고 인증할 수 있습니다. 디지털 서명을 통해 데이터를 서명하고 검증함으로써 데이터의 신뢰성을 보장할 수 있습니다.
    - **암호키 관리**: 암호화는 데이터를 암호화하고 복호화하는 데 사용되는 키(key)를 관리합니다. 이러한 키는 데이터의 보호를 위해 안전하게 보관되어야 합니다.
      주요한 암호화 기술에는 `대칭키 암호화`(Symmetric-key encryption)와 `공개키 암호화`(Public-key encryption)가 있습니다.
        - `대칭키 암호화`는 동일한 키를 사용하여 데이터를 암호화하고 복호화합니다.
        - 반면에 `공개키 암호화`는 `공개키`와 `개인키`를 사용하여 `데이터를 암호화하고 복호화`합니다. 대칭키 암호화는 일반적으로 속도가 빠르지만, 키 공유에 대한 문제가 있을 수 있습니다. 반면에
          공개키 암호화는 키 교환에 대한 문제를 해결할 수 있지만, 대칭키 암호화보다 속도가 느릴 수 있습니다.

> ### 공개키 암호화 <br>
>- 키 쌍 생성: 먼저 수신자는 공개키와 비밀키(개인키)라는 두 개의 키를 생성합니다. 공개키는 모두에게 공개되며, 비밀키는 수신자만 알고 있습니다.
>- 암호화: 송신자가 데이터를 보낼 때, 송신자는 수신자의 공개키를 사용하여 데이터를 암호화합니다. 이렇게 암호화된 데이터는 공개되어도 안전하게 전송될 수 있습니다.
>- 전송: 암호화된 데이터는 안전한 채널을 통해 수신자에게 전송됩니다.
>- 복호화: 수신자는 자신의 비밀키(개인키)를 사용하여 암호문을 복호화합니다. 비밀키는 오직 수신자만 알고 있으므로, 암호문을 해독할 수 있는 유일한 키입니다.
   > 공개키 암호화의 장점은 `보안성`과 `편의성`입니다. 송신자와 수신자는 `키를 안전하게 공유할 필요가 없으며`, `공개키는 누구에게나 공개`될 수 있으므로 편리하게 사용할 수 있습니다. 그러나 대칭키
   암호화에 비해 속도가 느리고 복잡할 수 있습니다.

> ### 데이터 무결성<br>
>데이터의 정확성, 일관성, 유효성이 유지되는 상태를 의미합니다. 즉, 데이터가 예상대로 정확하고 완전하며 유효한지를 나타냅니다.
>- 정확성 (Accuracy): 데이터가 실제로 나타내는 값이 정확한지를 나타냅니다. 예를 들어, 나이를 나타내는 데이터가 음수가 아닌지, 날짜가 올바른 형식인지 등을 확인할 수 있습니다.
>- 일관성 (Consistency): 데이터가 서로 모순되지 않고 일관된 값을 유지하는지를 나타냅니다. 예를 들어, 동일한 사람의 나이가 서로 다른 값으로 저장되어 있지 않는지를 확인할 수 있습니다.
>- 유효성 (Validity): 데이터가 정해진 규칙 또는 제약 조건을 준수하는지를 나타냅니다. 예를 들어, 사용자의 이메일 주소가 올바른 형식인지, 숫자 필드에 문자가 포함되어 있지 않은지 등을 확인할 수
   있습니다.
   > <br>
   > 데이터 무결성은 데이터베이스 관리 시스템(DBMS)에서 중요한 개념이며, 데이터베이스의 일관성과 신뢰성을 보장하는 데 중요한 역할을 합니다. 무결성 제약 조건을 사용하여 데이터베이스의 무결성을 유지할 수
   있습니다.

- 암호화는 보안에 중요한 요소이며, 데이터의 기밀성, 무결성 및 인증을 보장하는 데 필수적입니다. 그러나 올바른 암호화 기술과 안전한 키 관리 방법이 필요합니다. 잘못된 암호화 구현은 보안에 취약점을 노출시킬 수
  있으므로 주의해야 합니다.

--------------------

## 단방향 암호화 (One-way Encryption):

- 단방향 암호화는 평문(원본 데이터)을 암호화된 형태로 변환하지만, 암호화된 데이터를 다시 평문으로 되돌릴 수 없는 암호화 방법입니다.
- 즉, 암호화된 데이터를 복호화하여 원본 데이터를 얻을 수 없습니다. 대표적인 예로는 `해시 함수`가 있습니다.

### 특징

- 복호화 불가능: 암호화된 결과를 해독하여 평문으로 되돌릴 수 없습니다.
- 주로 `비밀번호 저장` 등에 사용됨: 사용자의 비밀번호를 저장할 때 주로 사용됩니다.
- 데이터 `무결성`을 보호: 데이터의 무결성을 확인하기 위해 `해시 값`을 사용할 수 있습니다.

----

## 양방향 암호화 (Two-way Encryption):

- 양방향 암호화는 평문을 암호화하여 암호문으로 변환할 뿐 아니라, 암호문을 다시 `복호화하여 원본 평문`을 얻을 수 있는 암호화 방법입니다.
- 대표적인 예로는 `대칭키 암호화`(Symmetric-key encryption)가 있습니다.

### 특징

- 복호화 가능: 암호화된 결과를 다시 평문으로 복호화하여 원본 데이터를 얻을 수 있습니다.
- 암호화와 복호화에 같은 키 사용: `대칭키 암호화`에서는 `동일한 키를 사용`하여 암호화와 복호화를 수행합니다.
- 안전한 키 관리가 필요: 키를 안전하게 관리하여 안전성을 유지해야 합니다.

## 각 방식의 사용 사례

- 단방향 암호화: 사용자의 비밀번호 저장, 데이터 무결성 검사 등에 주로 사용됩니다. 사용자의 비밀번호를 단방향으로 암호화하여 저장하면, 데이터베이스가 해킹당하더라도 원본 비밀번호를 알 수 없습니다.
- 양방향 암호화: 데이터를 보호하고 전송하는 데 사용됩니다. 데이터를 암호화하여 전송하고, 수신측에서는 해당 데이터를 복호화하여 원본 데이터를 얻습니다. 대칭키 암호화는 데이터를 안전하게 전송하기 위한
  SSL/TLS 프로토콜 등에 사용됩니다.
  양방향 암호화는 데이터를 암호화하고 복호화하는 데 사용되므로, 보안에 더 많은 기능과 고려 사항이 필요합니다. 특히 키의 안전한 관리가 중요합니다.

---

비밀번호를 안전하게 암호화하는 데에는 해싱 알고리즘을 사용하는 것이 일반적이다.

가장 간단한 해싱 알고리즘 중 하나는 SHA-256이다.
이 알고리즘을 사용하여 비밀번호를 해싱할 수 있다.
그러나 주의할 점은 해시만 사용하여 비밀번호를 저장하는 것은 안전하지 않다.
비밀번호에 솔트(salt)를 추가하고, 슬로우 해싱(slow hashing)을 적용하는 것이 좋다.
솔트를 추가하면 무차별 대입(brute-force) 공격을 어렵게 만들고, 슬로우 해싱은 공격자가 비밀번호를 무차별 대입하는 것을 느리게 만들어 보안을 강화합니다.


> ### 슬로우 해싱<br>
>- 해시 함수를 사용하여 비밀번호를 저장할 때, 일반적인 해싱보다 더 많은 계산 시간을 필요로 하는 방법 의미로 주로 보안을 강화하기 위해 사용됨.
>- 일반적인 해싱 함수는 입력값을 해시로 변환하는 데 상대적으로 적은 시간이 소요됩니다. 이는 공격자가 빠르게 다양한 입력값에 대한 해시를 계산하여 원본 값을 추측하는 데 도움이 될 수 있습니다. 따라서 해시
   함수가 빠를수록 공격자가 암호를 더 쉽게 해독할 수 있습니다.
>- 슬로우 해싱은 이러한 공격을 어렵게 만들기 위해 고안되었습니다. 슬로우 해싱은 해싱에 시간을 많이 소모하는 방식으로 작동합니다. 이것은 보안을 강화하는 데 도움이 됩니다. 공격자는 많은 시간과 자원을 투자하여
   각각의 가능성 있는 비밀번호에 대한 해시를 계산해야 하므로 공격이 더욱 어려워집니다.
>- 가장 널리 사용되는 슬로우 해싱 함수 중 하나는 bcrypt입니다. bcrypt는 해시 함수와 함께 "솔트(salt)"라는 임의의 데이터를 사용하여 보안성을 더욱 향상시킵니다. 이러한 슬로우 해싱 함수는 주로
   비밀번호 저장 및 인증 시스템에서 사용되며, 공격자가 비밀번호를 추측하는 것을 어렵게 만듭니다.
>- 슬로우 해싱은 보안을 강화하는 데 중요한 도구이며, 데이터베이스에서 사용자 비밀번호를 안전하게 저장하는 데 널리 사용됩니다.

```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

public class PasswordHashing {

    public static void main(String[] args) {
        String password = "password123"; // 사용자의 비밀번호

        // 랜덤 솔트 생성
        byte[] salt = generateSalt();

        // 비밀번호와 솔트를 함께 해싱
        String hashedPassword = hashPassword(password, salt);

        // 해싱된 비밀번호 출력
        System.out.println("Hashed Password: " + hashedPassword);
    }

    // 랜덤 솔트 생성
    public static byte[] generateSalt() {
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[16];
        // 무작위 바이트를 생성하여 지정된 배열에 저장, 솔트는 해싱 과정에서 사용되어 비밀번호를 보호하는 데에 도움이 된다.
        random.nextBytes(salt);
        return salt;
    }

    // 비밀번호와 솔트를 함께 해싱
    public static String hashPassword(String password, byte[] salt) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            // 해시 함수를 초기 상태로 재설정, 이전에 사용된 해시 함수의 내부 상태를 초기화
            digest.reset();
            //  해시 함수에 추가 데이터를 제공, 해시 함수는 비밀번호와 솔트를 함께 고려하여 해시된 출력을 생성
            digest.update(salt);
            // 해시 함수에 대한 최종 작업을 수행하고 해시된 결과를 반환하는 메서드 호출
            byte[] hashedBytes = digest.digest(password.getBytes());

            // 바이트 배열을 16진수 문자열로 변환
            StringBuilder sb = new StringBuilder();
            for (byte b : hashedBytes) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    }
}

```

- MessageDigest 클래스는 Java에서 해시 함수를 사용하여 메시지나 데이터를 해싱하는 데 사용됩니다. 이 클래스는 다양한 해시 알고리즘을 지원하며, 주로 데이터의 무결성을 보장하거나 데이터의 고유한
  식별자를 생성하는 데 사용됩니다.
- MessageDigest 클래스의 주요 메서드와 역할은 다음과 같습니다:
    - getInstance(String algorithm): 주어진 알고리즘 이름에 해당하는 MessageDigest 객체를 생성합니다. 주로 "MD5", "SHA-1", "SHA-256" 등의 알고리즘 이름을
      사용합니다.
    - reset(): 해시 함수의 내부 상태를 초기화합니다. 이는 새로운 해시 작업을 수행하기 전에 이전에 사용된 해시 함수의 상태를 초기화하는 데 사용됩니다.
    - update(byte[] input): 주어진 바이트 배열의 데이터를 해시 함수에 추가합니다. 이는 해시 함수가 데이터를 입력으로 받아 내부 상태를 업데이트하는 데 사용됩니다.
    - digest(): 해시 함수에 대한 최종 작업을 수행하고 해시된 결과를 반환합니다. 이는 마지막으로 입력된 데이터에 대한 최종 해시값을 생성하는 데 사용됩니다.

> MessageDigest 클래스는 보안 애플리케이션에서 많이 사용되며, 비밀번호 저장, 디지털 서명, 메시지 인증 코드 생성 등 다양한 보안 기능을 구현하는 데 활용됩니다. 그러나 이 클래스는 직접적으로 암호화
> 기능을 제공하지는 않습니다. 대신, 해시 함수를 사용하여 데이터의 무결성을 보장하고 보안을 강화합니다.

- SecureRandom 클래스는 Java에서 안전한 난수를 생성하는 데 사용됩니다. 난수는 예측할 수 없는 무작위 숫자를 의미하며, 보안 및 암호학적 용도로 사용될 때 예측 가능성이 없어야 합니다.
  SecureRandom 클래스는 이러한 요구 사항을 충족시키기 위해 구현되었습니다.
- SecureRandom 클래스는 다음과 같은 기능을 제공합니다:
    - 안전한 난수 생성: SecureRandom 클래스는 특정한 알고리즘에 기반하여 안전한 난수를 생성합니다. 이는 예측할 수 없는 무작위성을 보장하고 보안적인 요구 사항을 충족시킵니다.
    - 암호학적 용도로 사용 가능: SecureRandom 클래스는 암호학적으로 안전한 난수를 생성하기 때문에 보안 관련 작업에서 사용할 수 있습니다. 예를 들어, 비밀번호 솔트(salt) 생성, 암호키 생성,
      암호화 및 디지털 서명과 같은 작업에 활용됩니다.
    - 시스템 소금(salting): SecureRandom 클래스를 사용하여 무작위로 생성된 솔트는 해시 함수의 안전성을 향상시키는 데 사용됩니다. 솔트를 사용하면 공격자가 무차별 대입(brute-force)
      공격을 어렵게 만들 수 있습니다.
    - 플랫폼 독립적: SecureRandom 클래스는 Java 플랫폼에 독립적으로 구현되어 있으므로 다양한 운영 체제와 환경에서 사용할 수 있습니다.

> 보안 애플리케이션에서는 SecureRandom 클래스를 사용하여 보안에 중요한 역할을 하는 솔트 생성, 암호키 생성, 무작위 인증 토큰 생성 등에 활용됩니다. 이 클래스를 사용하여 안전한 난수를 생성하면
> 보안적인 요구 사항을 충족시키고 예측 불가능한 무작위성을 확보할 수 있습니다.

---

## 16진수를 사용하는 이유

바이트 배열을 16진수 문자열로 변환하는 이유는 주로 다음과 같습니다:

- 가독성: 바이트 배열을 16진수 문자열로 표현하면 각 바이트의 값이 직관적으로 이해되어 가독성이 높아집니다. 16진수는 각 바이트를 0부터 F까지의 두 자리 수로 표현하므로, 숫자와 알파벳을 혼합하여 표현할 수
  있습니다.
- 네트워크 통신: 네트워크 통신에서는 데이터를 16진수 문자열로 표현하는 것이 일반적입니다. 특히, HTTP 통신에서는 데이터를 16진수 문자열로 인코딩하여 전송하는 경우가 많습니다.
- 디버깅: 프로그램을 디버깅할 때, 바이트 배열을 16진수 문자열로 표현하면 해당 데이터를 더 쉽게 추적하고 이해할 수 있습니다. 특히, 이진 데이터를 읽거나 특정 프로토콜에서 전송된 데이터를 분석할 때
  유용합니다.
- 문자열 표현: 바이트 배열을 문자열로 저장하고 전송해야 할 때, 16진수 문자열은 이러한 요구 사항을 충족시키는 방법 중 하나입니다. 문자열로 저장하면 데이터를 텍스트 형식으로 다루기 쉽습니다.
- 암호화: 암호화된 데이터를 표현할 때, 보통 16진수 문자열로 표현합니다. 이는 암호화된 바이트 배열이 이해하기 어려울 수 있으므로 16진수로 표현하여 간단하게 표현할 수 있습니다.

따라서 바이트 배열을 16진수 문자열로 변환하는 것은 데이터를 표현하고 전송하는 데에 유용한 방법 중 하나입니다.

### 2진수(Binary):

2진수는 0과 1로 이루어져 있어 가독성이 낮습니다.
바이트 단위로 데이터를 표현할 때는 주로 사용되지만, 긴 이진수를 읽기 어려울 수 있습니다.

### 8진수(Octal):

8진수는 0부터 7까지의 숫자로 이루어져 있습니다.
2진수와 마찬가지로 가독성이 낮으며, 일반적으로는 잘 사용되지 않습니다.

### 10진수(Decimal):

10진수는 0부터 9까지의 숫자로 이루어져 있으며, 일상적으로 많이 사용됩니다.
각 자리의 의미를 이해하기 쉽고, 일반적으로는 가장 익숙한 진법입니다.
하지만 바이트 단위로 데이터를 표현할 때는 가독성이 떨어질 수 있습니다.

### 16진수(Hexadecimal):

16진수는 0부터 9까지의 숫자와 A부터 F까지의 알파벳으로 이루어져 있습니다.
각 자리가 4비트씩을 나타내므로, 바이트(8비트) 단위로 데이터를 표현하기에 이상적입니다.
숫자와 알파벳을 혼합하여 표현하므로 다양한 값을 간결하게 표현할 수 있습니다.
주로 메모리 주소, 바이너리 데이터, 암호화 키 등을 표현할 때 사용되며, 각 자리의 의미를 이해하기 쉽습니다.