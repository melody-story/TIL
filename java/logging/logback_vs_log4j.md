# logback과 log4j

## 공통점

- Apache Software Foundation에서 개발

## 차이점

1. 성능: Logback은 Log4j보다 더 효율적인 로깅을 제공합니다. 특히 Logback은 비동기 로깅을 지원하여 높은 처리량을 달성할 수 있습니다.
2. 구성: Logback은 더 단순하고 직관적인 구성을 가지고 있습니다. XML, Groovy 또는 프로그래밍 방식으로 설정할 수 있습니다. 반면에 Log4j는 복잡한 XML 구성 파일을 사용합니다.
3. 기능: Logback은 Log4j보다 몇 가지 기능을 더 제공합니다. 예를 들어, Logback은 SLF4J (Simple Logging Facade for Java)를 완전히 지원하며, 새로운 기능들과 개선된
   아키텍처를 포함하고 있습니다.
4. 확장성: Logback은 모듈화된 아키텍처를 가지고 있어서 추가 기능을 쉽게 확장할 수 있습니다. Log4j도 확장 가능하지만, Logback보다는 더 번거롭고 복잡할 수 있습니다.

logback

1. 비동기 로깅 지원: Logback은 비동기 로깅을 지원합니다. 이는 로그 메시지를 동기적으로 처리하는 대신, 별도의 스레드에서 로그 메시지를 비동기적으로 처리할 수 있습니다. 이로 인해 메인 애플리케이션
   스레드가 로깅 작업에 차단되지 않으므로 애플리케이션의 성능이 향상됩니다.
2. 효율적인 이벤트 처리: Logback은 내부적으로 이벤트 처리를 효율적으로 수행합니다. 메모리 사용 및 CPU 리소스를 최적화하여 높은 처리량을 달성할 수 있습니다.
3. GC(Garbage Collection) 최적화: Logback은 GC(Garbage Collection)을 최소화하기 위해 노력합니다. 로깅 이벤트를 생성할 때 발생하는 객체 생성을 최소화하고, 메모리 사용을
   최적화하여 GC의 영향을 줄입니다.

- Logback은 로깅 작업 중에 발생하는 Garbage Collection (GC)을 최적화하기 위해 다양한 방법을 활용합니다. 이를 통해 메모리 사용량을 최소화하고 GC의 빈도와 지연 시간을 줄이는 데에
  기여합니다. 아래는 Logback가 GC를 최적화하는 몇 가지 방법에 대한 설명입니다:
- 재사용 가능한 객체 사용: Logback은 로깅 이벤트를 생성할 때 가능한 한 많은 객체를 재사용합니다. 이는 로깅 이벤트를 생성할 때마다 새로운 객체를 생성하는 것이 아니라, 풀링된 객체를 사용하여 메모리
  할당과 GC의 부담을 줄입니다.
- 로깅 이벤트의 지연 초기화: Logback은 로깅 이벤트의 내용을 필요할 때까지 초기화하지 않습니다. 예를 들어, 로깅 이벤트를 생성할 때 로그 메시지를 포함한 문자열을 미리 연결하지 않습니다. 대신에, 이벤트를
  처리하는 시점에서 필요한 정보를 연결합니다. 이는 불필요한 객체 생성과 메모리 사용을 줄이며, GC의 빈도를 감소시킵니다.
- 메모리 관리 및 해제: Logback은 불필요한 메모리를 적절하게 관리하고 해제하여 GC의 작업을 최소화합니다. 로깅 이벤트 처리가 완료되면 사용한 자원을 즉시 반환하고 불필요한 참조를 제거하여 GC의 대상이
  되도록 합니다.
- 비동기 로깅: Logback은 비동기 로깅을 지원하여 로깅 작업을 메인 애플리케이션 스레드와 분리합니다. 이를 통해 로깅 작업에 의한 메인 스레드의 차단을 방지하고, GC의 영향을 최소화합니다.

# SLF4J (Simple Logging Facade 4 Java(간단한 자바를 위한 로깅 파사드))

- SLF4J는 인터페이스 프레임워크이기 때문에 단독으로 사용하지 않고, 로깅 프레임워크와 함께 사용합니다.
- 스프링 부트에서는 기본적으로 SLF4J와 Logback을 사용
- 다른 로깅 프레임워크 (예: Logback, Log4j, JUL 등)로의 추상화 계층을 제공하여 개발자가 어플리케이션 코드에서 로깅 시스템을 변경하지 않고도 로깅 프레임워크를 유연하게 교체할 수 있도록
  도와줍니다.
- SLF4J의 핵심 목표는 어플리케이션 코드가 특정 로깅 프레임워크에 결합되지 않도록 하는 것입니다. 대신에 SLF4J가 로깅 메시지를 로깅 시스템에 전달하고 실제 로깅 구현체에 대한 의존성을 완전히 분리하여,
  어플리케이션 코드와 로깅 시스템 간의 결합도를 최소화합니다.
- SLF4J를 사용하면 개발자는 어플리케이션 코드에서 직접 로깅 시스템을 호출하는 대신 SLF4J API를 사용하여 로깅을 수행합니다. 그런 다음 어플리케이션의 클래스패스에 있는 로깅 프레임워크의 구현체 중 하나를
  사용하여 로깅을 실제로 수행합니다. 이를 통해 로깅 프레임워크를 변경하더라도 어플리케이션 코드를 수정하지 않고 로깅 시스템을 교체할 수 있습니다.
- 따라서 SLF4J는 Java 어플리케이션의 로깅을 표준화하고 유연성을 높이는 데 도움이 되는 중요한 도구입니다.

# Facade

Facade는 객체 지향 디자인 패턴 중 하나로, 간단히 말해 인터페이스를 제공하여 복잡한 시스템이나 라이브러리의 일부 기능을 감싸고 간소화하는 역할을 합니다. 이는 클라이언트 코드가 복잡한 내부 구조를 알 필요
없이 간단하고 직관적인 인터페이스를 통해 기능을 사용할 수 있도록 합니다.
Facade 패턴의 주요 목적은 다음과 같습니다:
1. 단순한 인터페이스 제공: 복잡한 시스템의 내부를 감추고 단순한 인터페이스를 제공합니다. 클라이언트는 이 인터페이스를 통해 시스템의 기능을 사용할 수 있습니다.
2. 시스템의 결합도 감소: 클라이언트와 시스템 간의 결합도를 낮춥니다. 클라이언트는 시스템의 내부 구조에 대한 지식이 필요하지 않으며, 시스템의 변경이나 업그레이드에 대해 영향을 받지 않습니다.
3. 단일 진입점 제공: Facade는 시스템의 기능에 대한 단일 진입점을 제공합니다. 이를 통해 클라이언트는 여러 요소를 별도로 다루는 대신 하나의 인터페이스를 통해 모든 기능에 접근할 수 있습니다.
4. Facade 패턴은 소프트웨어의 구조를 단순화하고 유지보수성을 향상시키는 데에 유용합니다. 특히 복잡한 시스템이나 라이브러리를 사용할 때 클라이언트 코드를 간소화하고, 시스템의 변경에 유연하게 대응할 수 있도록
도와줍니다.